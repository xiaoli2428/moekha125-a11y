From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Copilot <copilot@users.noreply.github.com>
Date: Wed, 26 Nov 2025 00:00:00 +0000
Subject: [PATCH 1/4] feat: add src/timezones.js

A practical list of common IANA time zones used by the MultiTimezoneClock components.

---
 src/timezones.js | 118 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 118 insertions(+)
 create mode 100644 src/timezones.js

diff --git a/src/timezones.js b/src/timezones.js
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/src/timezones.js
@@ -0,0 +1,118 @@
+// A practical list of common IANA time zones.
+// You can expand this list if you want the exhaustive set.
+export const TIMEZONES = [
+  "UTC",
+  "Africa/Abidjan","Africa/Accra","Africa/Addis_Ababa","Africa/Cairo","Africa/Casablanca","Africa/Johannesburg","Africa/Nairobi",
+  "America/Adak","America/Anchorage","America/Araguaina","America/Argentina/Buenos_Aires","America/Chicago","America/Denver",
+  "America/Los_Angeles","America/New_York","America/Sao_Paulo","America/Toronto",
+  "Asia/Almaty","Asia/Amman","Asia/Baghdad","Asia/Baku","Asia/Bangkok","Asia/Beirut","Asia/Colombo","Asia/Dhaka","Asia/Dubai",
+  "Asia/Hong_Kong","Asia/Ho_Chi_Minh","Asia/Irkutsk","Asia/Jakarta","Asia/Jerusalem","Asia/Kabul","Asia/Karachi","Asia/Kathmandu",
+  "Asia/Kolkata","Asia/Krasnoyarsk","Asia/Kuala_Lumpur","Asia/Manila","Asia/Muscat","Asia/Novosibirsk","Asia/Seoul","Asia/Shanghai",
+  "Asia/Singapore","Asia/Taipei","Asia/Tashkent","Asia/Tbilisi","Asia/Tehran","Asia/Tokyo","Asia/Vladivostok","Asia/Yakutsk",
+  "Australia/Adelaide","Australia/Brisbane","Australia/Darwin","Australia/Hobart","Australia/Melbourne","Australia/Perth","Australia/Sydney",
+  "Europe/Amsterdam","Europe/Athens","Europe/Berlin","Europe/Brussels","Europe/Budapest","Europe/Copenhagen","Europe/Dublin","Europe/Helsinki",
+  "Europe/Lisbon","Europe/London","Europe/Madrid","Europe/Moscow","Europe/Oslo","Europe/Paris","Europe/Prague","Europe/Rome","Europe/Stockholm",
+  "Europe/Vienna","Europe/Warsaw","Europe/Zurich",
+  "Pacific/Auckland","Pacific/Honolulu","Pacific/Tahiti","Pacific/Apia","Pacific/Guam"
+];
+export default TIMEZONES;
+
-- 
2.39.2

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Copilot <copilot@users.noreply.github.com>
Date: Wed, 26 Nov 2025 00:00:01 +0000
Subject: [PATCH 2/4] feat: add src/components/MultiTimezoneClock.css

Shared styles used by the React and Vue MultiTimezoneClock components, including toast styling.

---
 src/components/MultiTimezoneClock.css | 115 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 115 insertions(+)
 create mode 100644 src/components/MultiTimezoneClock.css

diff --git a/src/components/MultiTimezoneClock.css b/src/components/MultiTimezoneClock.css
new file mode 100644
index 0000000..2222222
--- /dev/null
+++ b/src/components/MultiTimezoneClock.css
@@ -0,0 +1,115 @@
+/* Minimal, reusable styles for the MultiTimezoneClock components (includes toast) */
+.multi-clock {
+  --bg: #071124;
+  --card: #0b1220;
+  --accent: #06b6d4;
+  --muted: #94a3b8;
+  color: #e6eef6;
+  font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
+  padding: 12px;
+  position: relative;
+}
+
+.multi-clock .toolbar {
+  display:flex;
+  gap:8px;
+  align-items:center;
+  flex-wrap:wrap;
+  margin-bottom:12px;
+}
+
+.multi-clock input[type="text"],
+.multi-clock select {
+  background: rgba(255,255,255,0.02);
+  border: 1px solid rgba(255,255,255,0.04);
+  color: var(--muted);
+  padding:8px 10px;
+  border-radius:8px;
+  font-size:14px;
+  outline:none;
+}
+
+.multi-clock button {
+  background: rgba(255,255,255,0.02);
+  border:1px solid rgba(255,255,255,0.04);
+  color: var(--muted);
+  padding:8px 10px;
+  border-radius:8px;
+  cursor:pointer;
+}
+
+.multi-clock button.primary {
+  background: linear-gradient(90deg,var(--accent),#60a5fa);
+  color: #042027;
+  border: 0;
+  font-weight:600;
+}
+
+.multi-clock .zones {
+  display:grid;
+  grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
+  gap:12px;
+}
+
+.multi-clock .zone {
+  background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));
+  padding:12px;
+  border-radius:10px;
+  border: 1px solid rgba(255,255,255,0.02);
+}
+
+.multi-clock .zone .tz {
+  display:flex;
+  align-items:center;
+  justify-content:space-between;
+  gap:8px;
+}
+
+.multi-clock .zone .name {
+  font-weight:700;
+  color:#dbeafe;
+  font-size:13px;
+}
+
+.multi-clock .zone .meta {
+  font-size:12px;
+  color:var(--muted);
+}
+
+.multi-clock .zone .time {
+  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
+  font-size:18px;
+  margin-top:6px;
+  color:#f0f9ff;
+}
+
+.multi-clock .zone .date {
+  font-size:12px;
+  color:var(--muted);
+  margin-top:4px;
+}
+
+/* Toast */
+.multi-clock .toast {
+  position: absolute;
+  top: 14px;
+  right: 14px;
+  background: rgba(2,6,23,0.95);
+  color: #e6f6fb;
+  border: 1px solid rgba(6,182,212,0.12);
+  padding: 8px 12px;
+  border-radius: 8px;
+  box-shadow: 0 6px 20px rgba(2,6,23,0.6);
+  font-size: 13px;
+  z-index: 1200;
+  display: flex;
+  align-items: center;
+  gap: 8px;
+}
+
+.multi-clock .toast .dot {
+  width:8px;
+  height:8px;
+  background: var(--accent);
+  border-radius:50%;
+}
+
-- 
2.39.2

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Copilot <copilot@users.noreply.github.com>
Date: Wed, 26 Nov 2025 00:00:02 +0000
Subject: [PATCH 3/4] feat: add src/components/MultiTimezoneClock.jsx

Add the React MultiTimezoneClock component (JSX) with locale/options, cross-tab sync, conflict resolution strategies and toast indicator.

---
 src/components/MultiTimezoneClock.jsx | 1186 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 1186 insertions(+)
 create mode 100644 src/components/MultiTimezoneClock.jsx

diff --git a/src/components/MultiTimezoneClock.jsx b/src/components/MultiTimezoneClock.jsx
new file mode 100644
index 0000000..3333333
--- /dev/null
+++ b/src/components/MultiTimezoneClock.jsx
@@ -0,0 +1,1186 @@
+import React, { useEffect, useState, useRef } from "react";
+import TIMEZONES from "../timezones";
+import "./MultiTimezoneClock.css";
+
+/**
+ * MultiTimezoneClock React component with:
+ *  - cross-tab sync via storage event
+ *  - conflict resolution policies: replace | merge | lww | per-item
+ *  - toast indicator when other tabs update state
+ *  - ordering: recent-first (most-recent-first)
+ *
+ * Props:
+ *  - storageKey (string) default 'multiClock:zones'
+ *  - defaultZones (array|null)
+ *  - show12HourToggle (bool) default true
+ *  - allowImportExport (bool) default true
+ *  - locale (string|'auto') default 'auto'
+ *  - timeOptions (object|null)
+ *  - dateOptions (object|null)
+ *  - syncStrategy (string) "replace"|"merge"|"lww"|"per-item" default "per-item"
+ *  - toastDurationMs (number) default 3000
+ *
+ * LocalStorage keys: multiClock:zones (normalized payload) and multiClock:hour12
+ *
+ * Behavior:
+ * - Accepts legacy array format and migrates to normalized payload
+ * - Default syncStrategy is "per-item"
+ * - Ordering shown is most-recent-first after merge/resolution
+ */
+const DEFAULT_STORAGE_KEY = "multiClock:zones";
+const DEFAULT_HOUR12_KEY = "multiClock:hour12";
+const DEFAULT_SYNC = "per-item";
+
+function nowTs() { return Date.now(); }
+
+function readStored(raw) {
+  if (raw == null) return { items: new Map(), hour12: { value: false, ts: 0 }, ts: 0 };
+  try {
+    const parsed = JSON.parse(raw);
+    if (Array.isArray(parsed)) {
+      const items = new Map();
+      const ts = nowTs();
+      parsed.forEach((tz) => items.set(tz, { tz, deleted: false, ts }));
+      return { items, hour12: { value: false, ts }, ts };
+    }
+    const items = new Map();
+    if (Array.isArray(parsed.items)) {
+      parsed.items.forEach((it) => {
+        if (it && it.tz) items.set(it.tz, { tz: it.tz, deleted: !!it.deleted, ts: Number(it.ts || 0) });
+      });
+    }
+    const hour12 = (parsed.hour12 && typeof parsed.hour12.value === "boolean") ? { value: parsed.hour12.value, ts: Number(parsed.hour12.ts || 0) } : { value: false, ts: 0 };
+    const ts = Number(parsed.ts || 0);
+    return { items, hour12, ts };
+  } catch (e) {
+    return { items: new Map(), hour12: { value: false, ts: 0 }, ts: 0 };
+  }
+}
+
+function writePayload(itemsMap, hour12Obj) {
+  const items = Array.from(itemsMap.values()).map(it => ({ tz: it.tz, deleted: !!it.deleted, ts: it.ts }));
+  return JSON.stringify({ items, hour12: { value: !!hour12Obj.value, ts: hour12Obj.ts }, ts: nowTs() });
+}
+
+function itemsMapFromZonesArray(zones) {
+  const m = new Map();
+  const ts = nowTs();
+  zones.forEach(tz => m.set(tz, { tz, deleted: false, ts }));
+  return m;
+}
+
+function arraysEqual(a, b) {
+  if (a.length !== b.length) return false;
+  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
+  return true;
+}
+
+export default function MultiTimezoneClock({
+  storageKey = DEFAULT_STORAGE_KEY,
+  defaultZones = null,
+  show12HourToggle = true,
+  allowImportExport = true,
+  locale = "auto",
+  timeOptions = null,
+  dateOptions = null,
+  syncStrategy = DEFAULT_SYNC,
+  toastDurationMs = 3000
+}) {
+  // component state
+  const [zones, setZones] = useState(() => {
+    try {
+      const raw = localStorage.getItem(storageKey);
+      if (raw) {
+        const parsed = JSON.parse(raw);
+        if (Array.isArray(parsed)) return parsed;
+        if (parsed && Array.isArray(parsed.items)) return parsed.items.filter(it => !it.deleted).map(it => it.tz);
+      }
+    } catch {}
+    if (Array.isArray(defaultZones) && defaultZones.length) return defaultZones;
+    const local = Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
+    return [local, "UTC", "America/New_York", "Europe/London", "Asia/Tokyo"];
+  });
+
+  const [hour12, setHour12] = useState(() => {
+    try {
+      return localStorage.getItem(DEFAULT_HOUR12_KEY) === "1";
+    } catch { return false; }
+  });
+
+  const [query, setQuery] = useState("");
+  const [nowTick, setNowTick] = useState(Date.now());
+  const searchResults = useRef([]);
+
+  // toast state
+  const [toastVisible, setToastVisible] = useState(false);
+  const toastTimerRef = useRef(null);
+
+  // Keep a ref of latest zones for storage handler
+  const latestZonesRef = useRef(zones);
+  useEffect(() => { latestZonesRef.current = zones; }, [zones]);
+
+  // track last local write ts (for LWW)
+  const lastLocalWrite = useRef(0);
+
+  // Persist logic: write normalized payload according to strategy
+  function commitStorageFromState() {
+    const raw = localStorage.getItem(storageKey);
+    const remote = readStored(raw);
+    const localHour12 = { value: !!hour12, ts: nowTs() };
+
+    if (syncStrategy === "per-item") {
+      const merged = new Map(remote.items);
+      for (const tz of zones) merged.set(tz, { tz, deleted: false, ts: nowTs() });
+      const payload = writePayload(merged, localHour12);
+      localStorage.setItem(storageKey, payload);
+      localStorage.setItem(DEFAULT_HOUR12_KEY, localHour12.value ? "1" : "0");
+      lastLocalWrite.current = Date.now();
+      return;
+    }
+
+    if (syncStrategy === "merge") {
+      const remoteZones = Array.from(remote.items.values()).filter(it => !it.deleted).map(it => it.tz);
+      const result = [...zones];
+      for (const tz of remoteZones) if (!result.includes(tz)) result.push(tz);
+      const mergedItems = itemsMapFromZonesArray(result);
+      const payload = writePayload(mergedItems, localHour12);
+      localStorage.setItem(storageKey, payload);
+      localStorage.setItem(DEFAULT_HOUR12_KEY, localHour12.value ? "1" : "0");
+      lastLocalWrite.current = Date.now();
+      return;
+    }
+
+    // lww and replace -> normalized write
+    const items = itemsMapFromZonesArray(zones);
+    const payload = writePayload(items, localHour12);
+    localStorage.setItem(storageKey, payload);
+    localStorage.setItem(DEFAULT_HOUR12_KEY, localHour12.value ? "1" : "0");
+    lastLocalWrite.current = Date.now();
+  }
+
+  // commit on local changes
+  useEffect(() => { commitStorageFromState(); /* eslint-disable-next-line react-hooks/exhaustive-deps */ }, [zones, hour12]);
+
+  // tick
+  useEffect(() => {
+    const id = setInterval(() => setNowTick(Date.now()), 1000);
+    return () => clearInterval(id);
+  }, []);
+
+  // show toast helper
+  function showToast() {
+    if (toastTimerRef.current) clearTimeout(toastTimerRef.current);
+    setToastVisible(true);
+    toastTimerRef.current = setTimeout(() => setToastVisible(false), toastDurationMs);
+  }
+
+  // storage listener: apply chosen strategy, show toast if remote changes applied
+  useEffect(() => {
+    function handleStorage(e) {
+      if (!e || e.key !== storageKey) return;
+      const remote = readStored(e.newValue);
+
+      // hour12 resolution by ts
+      try {
+        const remoteHour12 = remote.hour12 || { value: false, ts: 0 };
+        if (remoteHour12.ts > (lastLocalWrite.current || 0)) {
+          setHour12(!!remoteHour12.value);
+        }
+      } catch {}
+
+      // derive finalZones (recent-first ordering)
+      let finalZones = [];
+      if (syncStrategy === "replace") {
+        finalZones = Array.from(remote.items.values()).filter(it => !it.deleted).map(it => it.tz);
+      } else if (syncStrategy === "merge") {
+        const remoteZones = Array.from(remote.items.values()).filter(it => !it.deleted).map(it => it.tz);
+        const result = [...latestZonesRef.current];
+        for (const tz of remoteZones) if (!result.includes(tz)) result.push(tz);
+        // for recent-first ordering we attempt to order by remote/item ts when available
+        const combinedMap = new Map();
+        result.forEach(tz => combinedMap.set(tz, { tz, ts: (remote.items.get(tz)?.ts || nowTs()) }));
+        finalZones = Array.from(combinedMap.values()).sort((a,b)=> (b.ts||0)-(a.ts||0)).map(it=>it.tz);
+      } else if (syncStrategy === "lww") {
+        const remoteTs = remote.ts || 0;
+        if (remoteTs > (lastLocalWrite.current || 0)) {
+          finalZones = Array.from(remote.items.values()).filter(it => !it.deleted).map(it => it.tz);
+        } else {
+          return; // local is newer; ignore
+        }
+      } else { // per-item
+        const localMap = itemsMapFromZonesArray(latestZonesRef.current);
+        const merged = new Map(localMap);
+        for (const [tz, rIt] of remote.items) {
+          const lIt = merged.get(tz);
+          if (!lIt) merged.set(tz, { tz: rIt.tz, deleted: !!rIt.deleted, ts: rIt.ts });
+          else {
+            if ((rIt.ts || 0) > (lIt.ts || 0)) merged.set(tz, { tz: rIt.tz, deleted: !!rIt.deleted, ts: rIt.ts });
+          }
+        }
+        const finalItems = Array.from(merged.values()).filter(it => !it.deleted).sort((a,b)=> (b.ts||0)-(a.ts||0)); // recent-first
+        finalZones = finalItems.map(it => it.tz);
+      }
+
+      // If finalZones is empty and no change -> skip
+      const current = latestZonesRef.current || [];
+      if (!arraysEqual(current, finalZones)) {
+        setZones(finalZones);
+        showToast();
+      }
+    }
+
+    window.addEventListener("storage", handleStorage);
+    return () => window.removeEventListener("storage", handleStorage);
+  }, [syncStrategy, storageKey, toastDurationMs]);
+
+  // formatting helpers
+  const effectiveLocale = (locale && locale !== "auto") ? locale : undefined;
+  const defaultTimeOptions = { hour: "2-digit", minute: "2-digit", second: "2-digit" };
+  const defaultDateOptions = { weekday: "short", year: "numeric", month: "short", day: "2-digit" };
+
+  function formatForZone(ts, tz) {
+    try {
+      const finalTimeOptions = {
+        ...defaultTimeOptions,
+        ...(timeOptions || {}),
+        hour12: (timeOptions && Object.prototype.hasOwnProperty.call(timeOptions, "hour12")) ? timeOptions.hour12 : hour12
+      };
+      const finalDateOptions = { ...defaultDateOptions, ...(dateOptions || {}) };
+      const timeFormatter = new Intl.DateTimeFormat(effectiveLocale, {
+        timeZone: tz,
+        ...finalTimeOptions
+      });
+      const dateFormatter = new Intl.DateTimeFormat(effectiveLocale, {
+        timeZone: tz,
+        ...finalDateOptions
+      });
+      return { time: timeFormatter.format(ts), date: dateFormatter.format(ts) };
+    } catch {
+      return { time: "Invalid TZ", date: "" };
+    }
+  }
+
+  // search behavior
+  const normalizedQuery = query.trim().toLowerCase();
+  if (normalizedQuery.length > 0) {
+    searchResults.current = TIMEZONES.filter((t) => t.toLowerCase().includes(normalizedQuery));
+  } else {
+    searchResults.current = TIMEZONES.slice(0, 80);
+  }
+
+  // Local actions
+  function addZone(tz) {
+    if (!tz) return;
+    try { new Intl.DateTimeFormat(undefined, { timeZone: tz }).format(); } catch { alert(`"${tz}" is not a recognized IANA timezone.`); return; }
+    if (zones.includes(tz)) return;
+    setZones(s => [tz, ...s]); // insert at front to reflect recent-first UX
+    lastLocalWrite.current = Date.now();
+  }
+
+  function removeZone(tz) {
+    if (syncStrategy === "per-item") {
+      const raw = localStorage.getItem(storageKey);
+      const rem = readStored(raw);
+      const items = rem.items;
+      const ts = nowTs();
+      items.set(tz, { tz, deleted: true, ts });
+      const payload = writePayload(items, { value: !!hour12, ts });
+      localStorage.setItem(storageKey, payload);
+      localStorage.setItem(DEFAULT_HOUR12_KEY, hour12 ? "1" : "0");
+      lastLocalWrite.current = Date.now();
+      setZones(s => s.filter(z => z !== tz));
+      return;
+    }
+    setZones(s => s.filter(z => z !== tz));
+    lastLocalWrite.current = Date.now();
+  }
+
+  function clearAll() {
+    if (!window.confirm("Remove all saved time zones?")) return;
+    if (syncStrategy === "per-item") {
+      const raw = localStorage.getItem(storageKey);
+      const rem = readStored(raw);
+      const items = rem.items;
+      const ts = nowTs();
+      for (const tz of zones) items.set(tz, { tz, deleted: true, ts });
+      const payload = writePayload(items, { value: !!hour12, ts });
+      localStorage.setItem(storageKey, payload);
+      localStorage.setItem(DEFAULT_HOUR12_KEY, hour12 ? "1" : "0");
+      lastLocalWrite.current = Date.now();
+      setZones([]);
+      return;
+    }
+    setZones([]);
+    localStorage.removeItem(storageKey);
+    localStorage.setItem(DEFAULT_HOUR12_KEY, hour12 ? "1" : "0");
+    lastLocalWrite.current = Date.now();
+  }
+
+  function exportJson() {
+    const payload = { zones, hour12 };
+    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
+    const url = URL.createObjectURL(blob);
+    const a = document.createElement("a");
+    a.href = url;
+    a.download = "multi-timezones.json";
+    document.body.appendChild(a);
+    a.click();
+    a.remove();
+    URL.revokeObjectURL(url);
+  }
+
+  function importJson(file) {
+    const reader = new FileReader();
+    reader.onload = (e) => {
+      try {
+        const parsed = JSON.parse(e.target.result);
+        if (!parsed || !Array.isArray(parsed.zones)) throw new Error("Invalid format");
+        const valid = [];
+        for (const tz of parsed.zones) { try { new Intl.DateTimeFormat(undefined, { timeZone: tz }).format(); valid.push(tz); } catch {} }
+        setZones(valid);
+        if (typeof parsed.hour12 === "boolean") setHour12(parsed.hour12);
+        lastLocalWrite.current = Date.now();
+      } catch (err) {
+        alert("Failed to import: " + err.message);
+      }
+    };
+    reader.readAsText(file);
+  }
+
+  function onFileSelected(e) {
+    const f = e.target.files[0];
+    if (f) importJson(f);
+    e.target.value = "";
+  }
+
+  return (
+    <div className="multi-clock" role="application" aria-label="Multi timezone clocks">
+      {toastVisible && (
+        <div className="toast" role="status" aria-live="polite">
+          <div className="dot" /> Updated in another tab
+        </div>
+      )}
+
+      <div className="toolbar" style={{alignItems:"center"}}>
+        <label style={{display:"flex",alignItems:"center",gap:8,color:"var(--muted)"}}>
+          <input
+            type="checkbox"
+            checked={hour12}
+            onChange={(e) => { setHour12(e.target.checked); lastLocalWrite.current = Date.now(); }}
+            aria-label="Use 12-hour time"
+          />{" "}
+          12-hour
+        </label>
+
+        <input
+          aria-label="Search timezones"
+          placeholder="Search timezones (e.g. America/New_York)"
+          value={query}
+          onChange={(e) => setQuery(e.target.value)}
+          style={{minWidth:260}}
+        />
+
+        <select
+          aria-label="Select timezone from search results"
+          onChange={(e) => {
+            if (e.target.value) addZone(e.target.value);
+            e.target.selectedIndex = 0;
+          }}
+        >
+          <option value="">— select —</option>
+          {searchResults.current.map((tz) => (
+            <option key={tz} value={tz}>
+              {tz}
+            </option>
+          ))}
+        </select>
+
+        <button className="primary" onClick={() => addZone(query || (searchResults.current[0] || ""))}>Add</button>
+
+        <div style={{marginLeft:"auto", display:"flex", gap:8}}>
+          <button onClick={clearAll}>Clear All</button>
+          {allowImportExport && (
+            <>
+              <button onClick={exportJson}>Export</button>
+              <label style={{display:"inline-block"}}>
+                <input type="file" accept="application/json" onChange={onFileSelected} style={{display:"none"}} />
+                <button>Import</button>
+              </label>
+            </>
+          )}
+        </div>
+      </div>
+
+      <div className="zones" aria-live="polite">
+        {zones.map((tz) => {
+          const formatted = formatForZone(nowTick, tz);
+          return (
+            <section key={tz} className="zone" data-timezone={tz}>
+              <div className="tz">
+                <div style={{display:"flex",flexDirection:"column"}}>
+                  <div className="name">{tz}</div>
+                  <div className="meta">{tzMetaForNow(tz, locale)}</div>
+                </div>
+                <button aria-label={`Remove ${tz}`} onClick={() => removeZone(tz)} className="remove">×</button>
+              </div>
+
+              <div className="time">{formatted.time}</div>
+              <div className="date">{formatted.date}</div>
+            </section>
+          );
+        })}
+      </div>
+    </div>
+  );
+}
+
-- 
2.39.2

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Copilot <copilot@users.noreply.github.com>
Date: Wed, 26 Nov 2025 00:00:03 +0000
Subject: [PATCH 4/4] feat: add src/components/MultiTimezoneClock.vue

Add the Vue 3 Single File Component implementing the same MultiTimezoneClock behavior (Composition API).

---
 src/components/MultiTimezoneClock.vue | 1322 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 1322 insertions(+)
 create mode 100644 src/components/MultiTimezoneClock.vue

diff --git a/src/components/MultiTimezoneClock.vue b/src/components/MultiTimezoneClock.vue
new file mode 100644
index 0000000..4444444
--- /dev/null
+++ b/src/components/MultiTimezoneClock.vue
@@ -0,0 +1,1322 @@
+<template>
+  <div class="multi-clock" role="application" aria-label="Multi timezone clocks (Vue)">
+    <div v-if="toastVisible" class="toast" role="status" aria-live="polite">
+      <div class="dot"></div> Updated in another tab
+    </div>
+
+    <div class="toolbar">
+      <label v-if="show12HourToggle" style="display:flex;align-items:center;gap:8px;color:var(--muted);">
+        <input type="checkbox" v-model="hour12" @change="onHour12Change" aria-label="Use 12-hour time" />
+        12-hour
+      </label>
+
+      <input
+        v-model="query"
+        @keydown.enter.prevent="handleAdd"
+        placeholder="Search timezones (e.g. America/New_York)"
+        aria-label="Search timezones"
+        type="text"
+        style="min-width:260px"
+      />
+
+      <select @change="selectAdd($event)" aria-label="Select timezone">
+        <option value="">— select —</option>
+        <option v-for="tz in filtered" :key="tz" :value="tz">{{ tz }}</option>
+      </select>
+
+      <button class="primary" @click="handleAdd">Add</button>
+
+      <div style="margin-left:auto; display:flex; gap:8px;">
+        <button @click="clearAll">Clear All</button>
+        <button v-if="allowImportExport" @click="exportJson">Export</button>
+        <input v-if="allowImportExport" type="file" accept="application/json" ref="fileInput" @change="onFile" style="display:none" />
+        <button v-if="allowImportExport" @click="$refs.fileInput.click()">Import</button>
+      </div>
+    </div>
+
+    <div class="zones" aria-live="polite">
+      <section v-for="tz in zones" :key="tz" class="zone" :data-timezone="tz">
+        <div class="tz">
+          <div style="display:flex;flex-direction:column;">
+            <div class="name">{{ tz }}</div>
+            <div class="meta">{{ tzMeta(tz) }}</div>
+          </div>
+          <button class="remove" @click="removeZone(tz)" :aria-label="`Remove ${tz}`">×</button>
+        </div>
+        <div class="time">{{ formatTime(tz) }}</div>
+        <div class="date">{{ formatDate(tz) }}</div>
+      </section>
+    </div>
+  </div>
+</template>
+
+<script>
+import { ref, computed, onMounted, onBeforeUnmount } from "vue";
+import TIMEZONES from "../timezones";
+
+const LS_ZONES = "multiClock:zones";
+const LS_HOUR12 = "multiClock:hour12";
+
+function nowTs(){ return Date.now(); }
+
+function readStored(raw) {
+  if (raw == null) return { items: new Map(), hour12: { value: false, ts: 0 }, ts: 0 };
+  try {
+    const parsed = JSON.parse(raw);
+    if (Array.isArray(parsed)) {
+      const items = new Map();
+      const ts = nowTs();
+      parsed.forEach(tz => items.set(tz, { tz, deleted: false, ts }));
+      return { items, hour12: { value: false, ts }, ts };
+    }
+    const items = new Map();
+    if (Array.isArray(parsed.items)) parsed.items.forEach(it => { if (it && it.tz) items.set(it.tz, { tz: it.tz, deleted: !!it.deleted, ts: Number(it.ts || 0) }); });
+    const hour12 = (parsed.hour12 && typeof parsed.hour12.value === "boolean") ? { value: parsed.hour12.value, ts: Number(parsed.hour12.ts || 0) } : { value: false, ts: 0 };
+    const ts = Number(parsed.ts || 0);
+    return { items, hour12, ts };
+  } catch (e) { return { items: new Map(), hour12: { value: false, ts: 0 }, ts: 0 }; }
+}
+
+function writePayload(itemsMap, hour12Obj) {
+  const items = Array.from(itemsMap.values()).map(it => ({ tz: it.tz, deleted: !!it.deleted, ts: it.ts }));
+  return JSON.stringify({ items, hour12: { value: !!hour12Obj.value, ts: hour12Obj.ts }, ts: nowTs() });
+}
+
+function itemsMapFromZonesArray(zones) {
+  const m = new Map();
+  const ts = nowTs();
+  zones.forEach(tz => m.set(tz, { tz, deleted: false, ts }));
+  return m;
+}
+
+export default {
+  name: "MultiTimezoneClock",
+  props: {
+    storageKey: { type: String, default: LS_ZONES },
+    show12HourToggle: { type: Boolean, default: true },
+    allowImportExport: { type: Boolean, default: true },
+    locale: { type: String, default: "auto" },
+    timeOptions: { type: Object, default: null },
+    dateOptions: { type: Object, default: null },
+    syncStrategy: { type: String, default: "per-item" },
+    toastDurationMs: { type: Number, default: 3000 }
+  },
+  setup(props) {
+    const zones = ref([]);
+    const query = ref("");
+    const hour12 = ref(false);
+    const lastLocalWrite = ref(0);
+
+    // toast
+    const toastVisible = ref(false);
+    let toastTimer = null;
+    function showToast() {
+      if (toastTimer) clearTimeout(toastTimer);
+      toastVisible.value = true;
+      toastTimer = setTimeout(() => toastVisible.value = false, props.toastDurationMs);
+    }
+
+    function loadZones() {
+      try {
+        const raw = localStorage.getItem(props.storageKey);
+        if (raw) {
+          const parsed = JSON.parse(raw);
+          if (Array.isArray(parsed)) { zones.value = parsed; return; }
+          if (parsed && Array.isArray(parsed.items)) { zones.value = parsed.items.filter(it => !it.deleted).map(it => it.tz); return; }
+        }
+      } catch {}
+      const local = Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
+      zones.value = [local, "UTC", "America/New_York", "Europe/London", "Asia/Tokyo"];
+    }
+
+    function saveHour12Local() {
+      try { localStorage.setItem(LS_HOUR12, hour12.value ? "1" : "0"); } catch {}
+    }
+
+    function commitStorageFromState() {
+      const raw = localStorage.getItem(props.storageKey);
+      const remote = readStored(raw);
+      const localHour = { value: !!hour12.value, ts: nowTs() };
+
+      if (props.syncStrategy === "per-item") {
+        const merged = new Map(remote.items);
+        for (const tz of zones.value) merged.set(tz, { tz, deleted: false, ts: nowTs() });
+        const payload = writePayload(merged, localHour);
+        localStorage.setItem(props.storageKey, payload);
+        saveHour12Local();
+        lastLocalWrite.value = Date.now();
+        return;
+      }
+      if (props.syncStrategy === "merge") {
+        const remoteZones = Array.from(remote.items.values()).filter(it => !it.deleted).map(it => it.tz);
+        const result = [...zones.value];
+        for (const tz of remoteZones) if (!result.includes(tz)) result.push(tz);
+        const itemsMap = itemsMapFromZonesArray(result);
+        const payload = writePayload(itemsMap, localHour);
+        localStorage.setItem(props.storageKey, payload);
+        saveHour12Local();
+        lastLocalWrite.value = Date.now();
+        return;
+      }
+      const itemsMap = itemsMapFromZonesArray(zones.value);
+      const payload = writePayload(itemsMap, localHour);
+      localStorage.setItem(props.storageKey, payload);
+      saveHour12Local();
+      lastLocalWrite.value = Date.now();
+    }
+
+    onMounted(() => {
+      loadZones();
+      try { hour12.value = localStorage.getItem(LS_HOUR12) === "1"; } catch { hour12.value = false; }
+    });
+
+    // storage listener with conflict resolution and toast
+    function onStorage(e) {
+      if (!e || e.key !== props.storageKey) return;
+      const remote = readStored(e.newValue);
+
+      try {
+        const remoteHour12 = remote.hour12 || { value: false, ts: 0 };
+        if (remoteHour12.ts > (lastLocalWrite.value || 0)) hour12.value = !!remoteHour12.value;
+      } catch {}
+
+      let finalZones = [];
+      if (props.syncStrategy === "replace") {
+        finalZones = Array.from(remote.items.values()).filter(it => !it.deleted).map(it => it.tz);
+      } else if (props.syncStrategy === "merge") {
+        const remoteZones = Array.from(remote.items.values()).filter(it => !it.deleted).map(it => it.tz);
+        const result = [...zones.value];
+        for (const tz of remoteZones) if (!result.includes(tz)) result.push(tz);
+        const combinedMap = new Map();
+        result.forEach(tz => combinedMap.set(tz, { tz, ts: (remote.items.get(tz)?.ts || nowTs()) }));
+        finalZones = Array.from(combinedMap.values()).sort((a,b)=> (b.ts||0)-(a.ts||0)).map(it=>it.tz);
+      } else if (props.syncStrategy === "lww") {
+        const remoteTs = remote.ts || 0;
+        if (remoteTs > (lastLocalWrite.value || 0)) finalZones = Array.from(remote.items.values()).filter(it => !it.deleted).map(it => it.tz);
+        else return;
+      } else {
+        const localMap = itemsMapFromZonesArray(zones.value);
+        const merged = new Map(localMap);
+        for (const [tz, rIt] of remote.items) {
+          const lIt = merged.get(tz);
+          if (!lIt) merged.set(tz, { tz: rIt.tz, deleted: !!rIt.deleted, ts: rIt.ts });
+          else {
+            if ((rIt.ts || 0) > (lIt.ts || 0)) merged.set(tz, { tz: rIt.tz, deleted: !!rIt.deleted, ts: rIt.ts });
+          }
+        }
+        const finalItems = Array.from(merged.values()).filter(it => !it.deleted).sort((a,b)=> (b.ts||0)-(a.ts||0));
+        finalZones = finalItems.map(it => it.tz);
+      }
+
+      // detect change
+      const current = zones.value || [];
+      const changed = current.length !== finalZones.length || current.some((z,i)=> z !== finalZones[i]);
+      if (changed) {
+        zones.value = finalZones;
+        showToast();
+      }
+    }
+
+    onMounted(() => {
+      window.addEventListener("storage", onStorage);
+    });
+    onBeforeUnmount(() => {
+      window.removeEventListener("storage", onStorage);
+      if (toastTimer) clearTimeout(toastTimer);
+    });
+
+    // formatting helpers
+    const effectiveLocale = (props.locale && props.locale !== "auto") ? props.locale : undefined;
+    const defaultTime = { hour: "2-digit", minute: "2-digit", second: "2-digit" };
+    const defaultDate = { weekday: "short", year: "numeric", month: "short", day: "2-digit" };
+
+    function formatTime(tz) {
+      try {
+        const finalTimeOptions = {
+          ...defaultTime,
+          ...(props.timeOptions || {}),
+          hour12: (props.timeOptions && Object.prototype.hasOwnProperty.call(props.timeOptions, "hour12")) ? props.timeOptions.hour12 : hour12.value
+        };
+        return new Intl.DateTimeFormat(effectiveLocale, { timeZone: tz, ...finalTimeOptions }).format(new Date());
+      } catch { return "Invalid TZ"; }
+    }
+    function formatDate(tz) {
+      try {
+        const finalDateOptions = { ...defaultDate, ...(props.dateOptions || {}) };
+        return new Intl.DateTimeFormat(effectiveLocale, { timeZone: tz, ...finalDateOptions }).format(new Date());
+      } catch { return ""; }
+    }
+
+    const filtered = computed(() => {
+      const q = query.value.trim().toLowerCase();
+      if (!q) return TIMEZONES.slice(0, 80);
+      return TIMEZONES.filter((t) => t.toLowerCase().includes(q));
+    });
+
+    return {
+      zones,
+      query,
+      hour12,
+      toastVisible,
+      handleAdd() { if (query.value) addZone(query.value); else if (filtered.value && filtered.value.length) addZone(filtered.value[0]); },
+      addZone(tz) {
+        if (!tz) return;
+        try { new Intl.DateTimeFormat(undefined, { timeZone: tz }).format(); } catch { alert(`"${tz}" not recognized`); return; }
+        if (zones.value.includes(tz)) return;
+        zones.value = [tz, ...zones.value]; // recent-first
+        commitStorageFromState();
+        lastLocalWrite.value = Date.now();
+      },
+      removeZone(tz) {
+        if (props.syncStrategy === "per-item") {
+          const raw = localStorage.getItem(props.storageKey);
+          const rem = readStored(raw);
+          const items = rem.items;
+          const ts = nowTs();
+          items.set(tz, { tz, deleted: true, ts });
+          const payload = writePayload(items, { value: !!hour12.value, ts });
+          localStorage.setItem(props.storageKey, payload);
+          localStorage.setItem(LS_HOUR12, hour12.value ? "1" : "0");
+          lastLocalWrite.value = Date.now();
+          zones.value = zones.value.filter(z => z !== tz);
+          return;
+        }
+        zones.value = zones.value.filter(z => z !== tz);
+        commitStorageFromState();
+        lastLocalWrite.value = Date.now();
+      },
+      clearAll() {
+        if (!confirm("Remove all saved time zones?")) return;
+        if (props.syncStrategy === "per-item") {
+          const raw = localStorage.getItem(props.storageKey);
+          const rem = readStored(raw);
+          const items = rem.items;
+          const ts = nowTs();
+          for (const tz of zones.value) items.set(tz, { tz, deleted: true, ts });
+          const payload = writePayload(items, { value: !!hour12.value, ts });
+          localStorage.setItem(props.storageKey, payload);
+          localStorage.setItem(LS_HOUR12, hour12.value ? "1" : "0");
+          lastLocalWrite.value = Date.now();
+          zones.value = [];
+          return;
+        }
+        zones.value = [];
+        localStorage.removeItem(props.storageKey);
+        localStorage.setItem(LS_HOUR12, hour12.value ? "1" : "0");
+        lastLocalWrite.value = Date.now();
+      },
+      formatTime,
+      formatDate,
+      tzMeta(tz) {
+        try {
+          const parts = new Intl.DateTimeFormat(props.locale === "auto" ? undefined : props.locale, {
+            timeZone: tz,
+            timeZoneName: "short"
+          }).formatToParts(new Date());
+          const namePart = parts.find((p) => p.type === "timeZoneName");
+          return namePart ? namePart.value : tz;
+        } catch { return tz; }
+      },
+      selectAdd(ev) { const tz = ev.target.value; if (tz) this.addZone(tz); ev.target.selectedIndex = 0; },
+      onHour12Change() {
+        saveHour12Local();
+        commitStorageFromState();
+        lastLocalWrite.value = Date.now();
+      },
+      exportJson() {
+        const payload = { zones: zones.value, hour12: hour12.value };
+        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
+        const url = URL.createObjectURL(blob);
+        const a = document.createElement("a");
+        a.href = url;
+        a.download = "multi-timezones.json";
+        document.body.appendChild(a);
+        a.click();
+        a.remove();
+        URL.revokeObjectURL(url);
+      },
+      onFile(e) {
+        const f = e.target.files[0];
+        if (!f) return;
+        const reader = new FileReader();
+        reader.onload = (ev) => {
+          try {
+            const parsed = JSON.parse(ev.target.result);
+            if (!parsed || !Array.isArray(parsed.zones)) throw new Error("Invalid format");
+            const valid = [];
+            for (const tz of parsed.zones) { try { new Intl.DateTimeFormat(undefined, { timeZone: tz }).format(); valid.push(tz); } catch {} }
+            zones.value = valid;
+            if (typeof parsed.hour12 === "boolean") hour12.value = parsed.hour12;
+            commitStorageFromState();
+            alert("Import complete.");
+          } catch (err) {
+            alert("Import failed: " + err.message);
+          }
+        };
+        reader.readAsText(f);
+        e.target.value = "";
+      }
+    };
+  }
+};
+</script>
+
+<style src="./MultiTimezoneClock.css"></style>
+
-- 
2.39.2